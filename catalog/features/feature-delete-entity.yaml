id: feature-delete-entity
version: 1.1.0
name: Delete Entity Feature Slice
category: feature-slice
intent: エンティティの削除機能（論理削除 or 物理削除）
description: |
  既存エンティティを削除する機能の垂直スライス。
  VSA.Frameworkの基底クラスを使用して、Command、Handler、Blazor Component を実装します。
  論理削除（Soft Delete）と物理削除（Hard Delete）の両方に対応。

scope: vertical-slice
layers:
  - application
  - domain
  - ui

ai_selection_hints:
  trigger_phrases:
    - "削除機能"
    - "削除できるように"
    - "を削除"
    - "除去"
    - "消去"
    - "Delete"

  confidence_keywords:
    high:    ["削除", "Delete", "除去", "消去"]
    medium:  ["削除ボタン", "削除処理"]
    low:     ["クリア", "リセット"]

  typical_requests:
    - "商品を削除できるようにしてください"
    - "タスクを削除する機能を追加して"
    - "ユーザーアカウントを削除できるようにしたい"

dependencies:
  patterns:
    - transaction-behavior
  nuget:
    - name: "VSA.Kernel"
      version: "1.3.0"
      purpose: "AggregateRoot, ITypedId, BoundaryDecision"
    - name: "VSA.Application"
      version: "1.3.0"
      purpose: "ICommand, Result<T>"
    - name: "VSA.Infrastructure"
      version: "1.3.0"
      purpose: "Pipeline Behaviors"
    - name: "VSA.Handlers"
      version: "1.3.0"
      purpose: "DeleteEntityHandler<T>"

file_structure: |
  src/Domain/{BoundedContext}/
  └── {Entity}.cs                      # Delete(), CanDelete() メソッド追加

  src/Application/Features/Delete{Entity}/
  ├── Delete{Entity}Command.cs         # Command (VSA.Application.ICommand<T>)
  └── Delete{Entity}Handler.cs         # Handler (VSA.Handlers.DeleteEntityHandler<T>)

  src/UI.Blazor/Features/{Entity}s/
  └── {Entity}List.razor               # 削除ボタン追加

implementation:
  # ===== Domain Layer =====
  entity:
    file_path: "src/Domain/{BoundedContext}/{Entity}.cs"
    template: |
      using VSA.Kernel;

      namespace Domain.{BoundedContext};

      public sealed class {Entity} : AggregateRoot<{Entity}Id>
      {
          // ... 既存のプロパティ ...

          public bool IsDeleted { get; private set; }
          public DateTime? DeletedAt { get; private set; }

          /// <summary>
          /// 削除可否を判定（Boundaryメソッド）
          /// </summary>
          public BoundaryDecision CanDelete()
          {
              // ビジネスルールに基づく判定
              // 例: 関連データがある場合は削除不可
              return BoundaryDecision.Allow();
          }

          /// <summary>
          /// 論理削除
          /// </summary>
          public void Delete()
          {
              IsDeleted = true;
              DeletedAt = DateTime.UtcNow;
          }
      }

  # ===== Application Layer =====
  command:
    file_path: "src/Application/Features/Delete{Entity}/Delete{Entity}Command.cs"
    template: |
      using VSA.Application;
      using VSA.Application.Interfaces;
      using Domain.{BoundedContext};

      namespace Application.Features.Delete{Entity};

      /// <summary>
      /// {Entity}削除Command
      /// </summary>
      public sealed record Delete{Entity}Command(
          {Entity}Id {Entity}Id
      ) : ICommand<Result<Unit>>;

  handler:
    file_path: "src/Application/Features/Delete{Entity}/Delete{Entity}Handler.cs"
    template: |
      using Microsoft.Extensions.Logging;
      using VSA.Application;
      using VSA.Handlers.Abstractions;
      using VSA.Handlers.Commands;
      using Domain.{BoundedContext};

      namespace Application.Features.Delete{Entity};

      /// <summary>
      /// {Entity}削除Handler（VSA.Handlers.DeleteEntityHandler を継承）
      /// </summary>
      public sealed class Delete{Entity}Handler
          : DeleteEntityHandler<Delete{Entity}Command, {Entity}, {Entity}Id>
      {
          public Delete{Entity}Handler(
              IRepository<{Entity}, {Entity}Id> repository,
              ILogger<Delete{Entity}Handler> logger)
              : base(repository, logger)
          {
          }

          protected override {Entity}Id GetEntityId(Delete{Entity}Command command)
          {
              return command.{Entity}Id;
          }

          protected override Result DeleteEntity({Entity} entity)
          {
              // Boundaryメソッドで削除可能かチェック
              var decision = entity.CanDelete();
              if (!decision.IsAllowed)
                  return Result.Fail(decision.Reason);

              // 論理削除
              entity.Delete();
              return Result.Success();

              // 物理削除の場合:
              // return Result.Success(); // Repository.DeleteAsyncが呼ばれる
          }
      }

  # ===== UI Layer =====
  blazor_component:
    file_path: "src/UI.Blazor/Features/{Entity}s/{Entity}List.razor"
    template: |
      @* 一覧画面に削除ボタンを追加 *@

      <button @onclick="() => DeleteAsync(item.Id)" class="btn-danger">
          削除
      </button>

      @code {
          private async Task DeleteAsync({Entity}Id id)
          {
              // 確認ダイアログを表示
              if (!await ConfirmAsync("{Entity}を削除しますか？"))
                  return;

              var command = new Delete{Entity}Command(id);
              var result = await Mediator.Send(command);

              if (result.IsSuccess)
              {
                  await RefreshAsync();
                  ShowSuccess("{Entity}を削除しました");
              }
              else
              {
                  ShowError(result.Error);
              }
          }
      }

ai_guidance:
  when_to_use:
    - "データを削除する機能を実装する場合"
    - "CRUDのD（Delete）を実装する場合"
    - "論理削除（Soft Delete）を実装する場合"

  when_not_to_use:
    - "新規作成 → feature-create-entity を使用"
    - "更新・編集 → feature-update-entity を使用"
    - "検索機能 → feature-search-entity を使用"

  implementation_steps:
    - step: 1
      description: "Domain層に Delete() と CanDelete() メソッドを追加"
      files: ["{Entity}.cs"]

    - step: 2
      description: "Application層に Command + Handler を作成"
      files: ["Delete{Entity}Command.cs", "Delete{Entity}Handler.cs"]

    - step: 3
      description: "UI層に削除ボタンと確認ダイアログを追加"

  common_mistakes:
    - mistake: "物理削除と論理削除を混同する"
      solution: "論理削除: IsDeleted フラグ、物理削除: repository.DeleteAsync()。監査要件がある場合は論理削除を推奨。"

    - mistake: "削除前のビジネスルール検証を省略する"
      solution: "Domain層の CanDelete() メソッドでBoundaryDecisionを返す"

    - mistake: "確認ダイアログを実装しない"
      solution: "削除は不可逆操作のため、UI層で必ず確認ダイアログを表示する"

    - mistake: "Handler内でSaveChangesAsync()を呼ぶ"
      solution: "TransactionBehaviorが自動でSaveChangesAsyncを呼ぶため不要"

  design_decision:
    soft_delete_vs_hard_delete: |
      論理削除（Soft Delete）を推奨する場合:
      - 監査要件がある（削除履歴を保持する必要がある）
      - データ復元の可能性がある
      - 関連データとの整合性を保つ必要がある

      物理削除（Hard Delete）を使用する場合:
      - GDPR等の法規制で完全削除が必要
      - ストレージコスト削減が必要
      - テストデータのクリーンアップ

changelog:
  - version: 1.1.0
    date: 2025-12-28
    changes:
      - "VSA.Framework統合"
      - "NuGetパッケージ参照に変更"
      - "汎用ハンドラー使用を推奨"

  - version: 1.0.0
    date: 2025-11-19
    changes:
      - "初版リリース"
